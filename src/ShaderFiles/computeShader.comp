#version 460 core
layout(local_size_x = 8, local_size_y = 4) in;
layout(r32f, binding = 0) uniform image2D u_cascade1Depth;  // Coarse
layout(r32f, binding = 1) uniform image2D u_cascade2Depth;  // Medium
layout(r32f, binding = 2) uniform image2D u_cascade3Depth;  // Fine
layout(rgba32f, binding = 3) uniform image2D u_output;

#include "hg_sdf.hlsl"

// ──────────────────────────────────────────────────────────────────────── //
//                            VARIABLES & UNIFORMS                          //
// ──────────────────────────────────────────────────────────────────────── //
uniform ivec2 u_fullRes;
uniform ivec2 u_cascade1Res;    // Coarse grid resolution
uniform ivec2 u_cascade2Res;    // Medium grid resolution
uniform ivec2 u_cascade3Res;    // Fine grid resolution
uniform float u_fov;
uniform float u_time;
uniform int   u_passType;       // 0 = cascade1, 1 = cascade2, 2 = cascade3, 3 = main raymarch

// ─────────────────────────── Camera & Output ──────────────────────────── //
uniform vec3  u_camPos;
uniform vec3  u_camRot;
uniform int   u_buffer;     

// ─────────────────────────── Render constants ─────────────────────────── //
const float   u_maxDist = 100.0f;
const float   u_epsilon = 0.001f;
const int     u_maxStepsCone = 128;
const int     u_maxStepsMain = 128;

const vec3    u_bgColor = vec3(0.05f, 0.05f, 0.1f);

// ──────────────────────────────────────────────────────────────────────── //
//                              TYPES & UTILITIES                           //
// ──────────────────────────────────────────────────────────────────────── //

struct Ray {
    vec3 origin;
    vec3 dir;
};

float smin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

// ──────────────────────────────────────────────────────────────────────── //
//                             CAMERA & RAY SETUP                           //
// ──────────────────────────────────────────────────────────────────────── //

Ray makePrimaryRay(vec2 fragCoord, vec2 resolution) {
    // Normalize coordinates to [0, 1] and convert to [-1, 1]
    vec2 ndc = (fragCoord / resolution) * 2.0f - 1.0f;
    float aspect = resolution.x / resolution.y;
    ndc.x *= aspect;
    
    // ───────────────────── //
    //    Camera  rotation   //
    // ───────────────────── //
    float pitch = u_camRot.x;
    float yaw = u_camRot.y;

    float cp = cos(pitch);
    float sp = sin(pitch);
    float cy = cos(yaw);
    float sy = sin(yaw);

    mat3 rotX = mat3(
        1.0, 0.0, 0.0,
        0.0, cp, -sp,
        0.0, sp,  cp
    );

    mat3 rotY = mat3(
         cy, 0.0, sy,
         0.0, 1.0, 0.0,
        -sy, 0.0, cy
    );
    // ───────────────────── //
    // ───────────────────── //
    // ───────────────────── //

    vec3 rayDir = normalize(vec3(ndc * u_fov, 1.0));
    vec3 rotatedRayDir  = normalize(rotY * rotX * rayDir);

    Ray r;
    r.origin = u_camPos;
    r.dir    = rotatedRayDir;
    return r;
}

// ──────────────────────────────────────────────────────────────────────── //
//                             SDF SCENE COMPUTE                            //
// ──────────────────────────────────────────────────────────────────────── //
vec4 qSquare( in vec4 q )
{
    return vec4(q.x*q.x - q.y*q.y - q.z*q.z - q.w*q.w, 2.0*q.x*q.yzw);
}
vec4 qCube( in vec4 q )
{
    vec4  q2 = q*q;
    return vec4(q.x  *(    q2.x - 3.0*q2.y - 3.0*q2.z - 3.0*q2.w), 
                q.yzw*(3.0*q2.x -     q2.y -     q2.z -     q2.w));
}
float qLength2( in vec4 q ) { return dot(q,q); }

vec2 JS( in vec3 p )
{
    vec4 z = vec4( p, 0.0 );
    float dz2 = 1.0;
	float m2  = 0.0;
    float n   = 0.0;
    const vec4  kC = vec4(-2,6,15,-6)/22.0;
    //const vec4  kC = vec4(1,-0.4,-.4,.2);
    #ifdef TRAPS
    float o   = 1e10;
    #endif
    
    for( int i=0; i<200; i++ ) 
	{
        // z' = 3z² -> |z'|² = 9|z²|²
		dz2 *= 9.0*qLength2(qSquare(z));
        
        // z = z³ + c		
		z = qCube( z ) + kC;
        
        // stop under divergence		
        m2 = qLength2(z);		

        // orbit trapping : https://iquilezles.org/articles/orbittraps3d
        #ifdef TRAPS
        o = min( o, length(z.xz-vec2(0.45,0.55))-0.1 );
        #endif
        
        // exit condition
        if( m2>256.0 ) break;				 
		n += 1.0;
	}
   
	// sdf(z) = log|z|·|z|/|dz| : https://iquilezles.org/articles/distancefractals
	float d = 0.25*log(m2)*sqrt(m2/dz2);
    
    #ifdef TRAPS
    d = min(o,d);
    #endif
    #ifdef CUT
    d = max(d, p.y);
    #endif
    
	return vec2(d, n);        
}

// Simple demo scene: a sphere over a floor
float sdfScene(vec3 p) {
    float cubeDisplaycment = cos(u_time / 3.0) * 0.5 + 1.25;
    return max(JS(p).r, -(fBox(vec3(p) - vec3(0, cubeDisplaycment, 0.15f) , vec3(1.15f))));
}

// ──────────────────────────────────────────────────────────────────────── //
//                             NORMAL & SHADING                             //
// ──────────────────────────────────────────────────────────────────────── //

vec3 calcNormal(vec3 p) {
    const vec2 e = vec2(1.0, -1.0) * 0.001;

    return normalize(
        e.xyy * sdfScene(p + e.xyy) +
        e.yyx * sdfScene(p + e.yyx) +
        e.yxy * sdfScene(p + e.yxy) +
        e.xxx * sdfScene(p + e.xxx)
    );
}

vec3 shade(vec3 pos, vec3 n, vec3 rayDir) {
    vec3 lightDir = normalize(vec3(0.3, 0.7, 0.2));
    float diff    = max(dot(n, lightDir), 0.0);
    float spec    = pow(max(dot(reflect(-lightDir, n), -rayDir), 0.0), 32.0);

    vec3 baseColor = vec3(0.4, 0.75, 1.0);
    vec3 col = baseColor * (0.2 + 0.8 * diff) + vec3(1.0) * spec * 0.25;
    return col;
}

// ──────────────────────────────────────────────────────────────────────── //
//                          CASCADING CONE PREPASS                          //
//                    Cascade1 → Cascade2 → Cascade3 → Main                 //
// ──────────────────────────────────────────────────────────────────────── //

// Cascade 1: Coarse pass
void runCascade1(ivec2 gliID) {
    vec2 pixelsPerCell = vec2(u_fullRes) / vec2(u_cascade1Res);
    vec2 fullResCoord = (vec2(gliID) + vec2(0.5)) * pixelsPerCell;
    
    Ray ray = makePrimaryRay(fullResCoord, vec2(u_fullRes));

    float blockHalf = max(pixelsPerCell.x, pixelsPerCell.y) * 0.5;
    float pixelSizeY_at_z1 = 2.0 * tan(u_fov * 0.5) / float(u_fullRes.y);
    float coneAngle = blockHalf * pixelSizeY_at_z1;

    float t = 0.0;
    float safeT = u_maxDist;

    for (int i = 0; i < u_maxStepsCone; ++i) {
        vec3 pos = ray.origin + t * ray.dir;
        float d = sdfScene(pos);
        float cr = t * coneAngle;

        if (d <= cr) {
            safeT = max(t - cr, 0.0);
            break;
        }

        float stepLen = max(d - cr, 0.001);
        t += stepLen;

        if (t > u_maxDist)
            break;
    }

    imageStore(u_cascade1Depth, gliID, vec4(safeT));
}

// Cascade 2: Medium pass (refines cascade1 hits)
void runCascade2(ivec2 gliID) {
    vec2 cascade2toCascade1 = vec2(u_cascade1Res) / vec2(u_cascade2Res);
    ivec2 cascade1ID = ivec2(vec2(gliID) * cascade2toCascade1);
    cascade1ID = clamp(cascade1ID, ivec2(0), u_cascade1Res - ivec2(1));

    float cascade1Depth = imageLoad(u_cascade1Depth, cascade1ID).r;
    
    if (cascade1Depth >= u_maxDist - 1e-3) {
        imageStore(u_cascade2Depth, gliID, vec4(u_maxDist));
        return;
    }

    vec2 pixelsPerCell = vec2(u_fullRes) / vec2(u_cascade2Res);
    vec2 fullResCoord = (vec2(gliID) + vec2(0.5)) * pixelsPerCell;
    
    Ray ray = makePrimaryRay(fullResCoord, vec2(u_fullRes));

    float blockHalf = max(pixelsPerCell.x, pixelsPerCell.y) * 0.5;
    float pixelSizeY_at_z1 = 2.0 * tan(u_fov * 0.5) / float(u_fullRes.y);
    float coneAngle = blockHalf * pixelSizeY_at_z1;

    // Start from cascade1's depth to skip already-marched distance
    float t = max(cascade1Depth - 0.5, 0.0);  // Small margin for safety
    float safeT = u_maxDist;

    for (int i = 0; i < u_maxStepsCone; ++i) {
        vec3 pos = ray.origin + t * ray.dir;
        float d = sdfScene(pos);
        float cr = t * coneAngle;

        if (d <= cr) {
            safeT = max(t - cr, 0.0);
            break;
        }

        float stepLen = max(d - cr, 0.001);
        t += stepLen;

        if (t > u_maxDist)
            break;
    }

    imageStore(u_cascade2Depth, gliID, vec4(safeT));
}

// Cascade 3: Fine pass (refines cascade2 hits)
void runCascade3(ivec2 gliID) {
    vec2 cascade3toCascade2 = vec2(u_cascade2Res) / vec2(u_cascade3Res);
    ivec2 cascade2ID = ivec2(vec2(gliID) * cascade3toCascade2);
    cascade2ID = clamp(cascade2ID, ivec2(0), u_cascade2Res - ivec2(1));

    float cascade2Depth = imageLoad(u_cascade2Depth, cascade2ID).r;
    
    if (cascade2Depth >= u_maxDist - 1e-3) {
        imageStore(u_cascade3Depth, gliID, vec4(u_maxDist));
        return;
    }

    vec2 pixelsPerCell = vec2(u_fullRes) / vec2(u_cascade3Res);
    vec2 fullResCoord = (vec2(gliID) + vec2(0.5)) * pixelsPerCell;
    
    Ray ray = makePrimaryRay(fullResCoord, vec2(u_fullRes));

    float blockHalf = max(pixelsPerCell.x, pixelsPerCell.y) * 0.5;
    float pixelSizeY_at_z1 = 2.0 * tan(u_fov * 0.5) / float(u_fullRes.y);
    float coneAngle = blockHalf * pixelSizeY_at_z1;

    // Start from cascade2's depth to skip already-marched distance
    float t = max(cascade2Depth - 0.5, 0.0);  // Small margin for safety
    float safeT = u_maxDist;

    for (int i = 0; i < u_maxStepsCone; ++i) {
        vec3 pos = ray.origin + t * ray.dir;
        float d = sdfScene(pos);
        float cr = t * coneAngle;

        if (d <= cr) {
            safeT = max(t - cr, 0.0);
            break;
        }

        float stepLen = max(d - cr, 0.001);
        t += stepLen;

        if (t > u_maxDist)
            break;
    }

    imageStore(u_cascade3Depth, gliID, vec4(safeT));
}

// ──────────────────────────────────────────────────────────────────────── //
//                          MAIN RAY MARCH (PASS 1)                         //
// ──────────────────────────────────────────────────────────────────────── //

float sampleConeDepthBilinear(ivec2 pixel) {
    // Map full-res pixel to cascade3 grid float coords
    vec2 scale = vec2(u_cascade3Res) / vec2(u_fullRes);
    vec2 gridPos = (vec2(pixel) + vec2(0.5)) * scale - vec2(0.5);

    ivec2 i0 = ivec2(floor(gridPos));
    ivec2 i1 = i0 + ivec2(1, 0);
    ivec2 i2 = i0 + ivec2(0, 1);
    ivec2 i3 = i0 + ivec2(1, 1);

    vec2 f = fract(gridPos);

    i0 = clamp(i0, ivec2(0), u_cascade3Res - ivec2(1));
    i1 = clamp(i1, ivec2(0), u_cascade3Res - ivec2(1));
    i2 = clamp(i2, ivec2(0), u_cascade3Res - ivec2(1));
    i3 = clamp(i3, ivec2(0), u_cascade3Res - ivec2(1));

    float d00 = imageLoad(u_cascade3Depth, i0).r;
    float d10 = imageLoad(u_cascade3Depth, i1).r;
    float d01 = imageLoad(u_cascade3Depth, i2).r;
    float d11 = imageLoad(u_cascade3Depth, i3).r;

    float dx0 = mix(d00, d10, f.x);
    float dx1 = mix(d01, d11, f.x);
    float d   = mix(dx0, dx1, f.y);

    return d;
}

void runMainRaymarch(ivec2 gliID) {
    Ray ray = makePrimaryRay(gliID, u_fullRes);
    float tCone = sampleConeDepthBilinear(gliID);

    // If cone pass didn't hit anything, tCone will be ~u_maxDist
    if (tCone >= u_maxDist - 1e-3) {
        imageStore(u_output, gliID, vec4(u_bgColor, 1.0));
        if(u_buffer != 3) return;
    }

    // Start a bit *before* cone depth to be safe
    float t = max(tCone - 1.0, 0.0);

    bool hit = false;
    vec3 hitPos = vec3(0.0);
    int stepCount = 0;
    float minDistance = u_maxDist;  // Track minimum distance to surface (for glow)

    for (int i = 0; i < u_maxStepsMain; ++i) {
        hitPos = ray.origin + t * ray.dir;
        float d = sdfScene(hitPos);
        
        minDistance = min(minDistance, d);  // Track closest approach
        stepCount = i;

        if (d < u_epsilon) {
            hit = true;
            break;
        }

        t += d;
        if (t > u_maxDist)
            break;
    }

    vec4 outCol = vec4(u_bgColor, 1.0);

    if (hit) {
        vec3 n   = calcNormal(hitPos);
        vec3 col = shade(hitPos, n, ray.dir);
        
        // Color based on iteration count (step count)
        vec3 iterCol = vec3(sin(float(stepCount) * 0.1) * 0.5 + 0.5,
                            cos(float(stepCount) * 0.15) * 0.5 + 0.5,
                            sin(float(stepCount) * 0.05 + 2.0) * 0.5 + 0.5);
        
        // Blend iteration coloring with surface color
        col = mix(col, iterCol, 0.3);
        
        // Add glow based on distance traveled (closer = more glow)
        float glow = pow(1.0 - (t / u_maxDist), 3.0) * 0.5;
        col += vec3(0.5, 0.6, 1.0) * glow;  // Cyan/blue glow
        
        outCol = vec4(col, 1.0);
    }

    // ───────────────────────────────────────────────────────────────────────────── //
    // ─────────────────────────── DISPLAY DEBUG BUFFERS ─────────────────────────── //
    // ───────────────────────────────────────────────────────────────────────────── //

    switch(u_buffer)
    {
        case 0:
            // Visualize final color
            outCol = outCol;
            // I guess this case doesn't require any explanation
            break;
        
        case 1:
            // Visualize normals
            outCol = vec4(calcNormal(hitPos), 1.0);
            break;

        case 2:
            // Visualize step count
            outCol = vec4(vec3(float(stepCount) / float(u_maxStepsMain)), 1.0);
            break;

        case 3:
            // Visualize cascade depth
            outCol = vec4(0.0);
            // Check cascade 1
            float depthLoaded = imageLoad(u_cascade1Depth, ivec2(vec2(gliID) * vec2(u_cascade1Res) / vec2(u_fullRes))).r;
            if(depthLoaded >= u_maxDist - 1e-3) outCol += vec4(0.2, 0.0, 0.0, 1.0);
            else outCol                                += vec4(0.0, 0.2, 0.0, 1.0);
            
            depthLoaded = 0.0;
            // Check cascade 2
            depthLoaded = imageLoad(u_cascade2Depth, ivec2(vec2(gliID) * vec2(u_cascade2Res) / vec2(u_fullRes))).r;
            if(depthLoaded >= u_maxDist - 1e-3) outCol += vec4(0.2, 0.0, 0.0, 1.0);
            else outCol                                += vec4(0.0, 0.2, 0.0, 1.0);

            depthLoaded = 0.0;
            // Check cascade 3
            depthLoaded = imageLoad(u_cascade3Depth, ivec2(vec2(gliID) * vec2(u_cascade3Res) / vec2(u_fullRes))).r;
            if(depthLoaded >= u_maxDist - 1e-3) outCol += vec4(0.2, 0.0, 0.0, 1.0);
            else outCol                                += vec4(0.0, 0.2, 0.0, 1.0);

            break;
        case 4:
            // Visualize minimum distance to surface (for misses)
            outCol = vec4(vec3(clamp(minDistance / 1.0, 0.0, 1.0)), 1.0);
            break;

    }

    imageStore(u_output, gliID, outCol);

    // ───────────────────────────────────────────────────────────────────────────── //
    // ───────────────────────────────────────────────────────────────────────────── //
    // ───────────────────────────────────────────────────────────────────────────── //

}

// ──────────────────────────────────────────────────────────────────────── //
//                             MAIN ENTRY OUTPUT                            //
// ──────────────────────────────────────────────────────────────────────── //

void main() {
    ivec2 gliID = ivec2(gl_GlobalInvocationID.xy);

    if (u_passType == 0) {
        if (gliID.x < u_cascade1Res.x && gliID.y < u_cascade1Res.y) {
            runCascade1(gliID);
        }
    } 
    else if (u_passType == 1) {
        if (gliID.x < u_cascade2Res.x && gliID.y < u_cascade2Res.y) {
            runCascade2(gliID);
        }
    }
    else if (u_passType == 2) {
        if (gliID.x < u_cascade3Res.x && gliID.y < u_cascade3Res.y) {
            runCascade3(gliID);
        }
    }
    else if (u_passType == 3) {
        if (gliID.x < u_fullRes.x && gliID.y < u_fullRes.y) {
            runMainRaymarch(gliID);
        }
    }
}
